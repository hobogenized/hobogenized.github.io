<!DOCTYPE HTML>
<head>
	<title>Final Graphics Project</title>
	 <script src="https://ajax.googleapis.com/ajax/libs/jquery/1.11.3/jquery.min.js"></script>
	<script src=CT_Modeler.js></script>
</head>
<body style="background:white;">


<script>
	var pressedKeys = {};

	var translX = 0,
	    translY = 0,
		translZ = 0;
	
	var mouseDown = false,
		growBigger = false,
		shrinkSmaller = false;
		
	var deltaMouseX = 0,
	    deltaMouseY = 0;
	
	var scaleFactor = 2,
		mouseScale = 3;

	var worldTransform = CT.matrixIdentity();
	
	var camera;
	
    // called when the pointer lock has changed. Here we check whether the
    // pointerlock was initiated on the element we want.
    function changeCallback(e) {
		(function($){
        var canvas = $("#pointerLock").get()[0];
		 })(jQuery); 
        if (document.pointerLockElement === canvas ||
                document.mozPointerLockElement === canvas ||
                document.webkitPointerLockElement === canvas) {
 
            // we've got a pointerlock for our element, add a mouselistener
            document.addEventListener("mousemove", moveCallback, false);
        } else {
 
            // pointer lock is no longer active, remove the callback
            document.removeEventListener("mousemove", moveCallback, false);
 
            // and reset the entry coordinates
            entryCoordinates = {x:-1, y:-1};
        }
    };

	function init() {
		var sin = Math.sin, cos = Math.cos, PI = Math.PI;

		window.scene = new CT.Scene(canvas1);
		scene.setLight(0, [1,1,1]);

		window.obj = new CT.Node().scale(.1);
		scene.add(obj);
		
		/*
		var obj1 = new CT.Node();
		obj.addChild(obj1);

		obj1.addChild(new CT.Cube());
		obj1.getChild(0).setTexture('images/xy.png');

		obj1.addChild(new CT.Cylinder(8));
		obj1.getChild(1).setFragmentShader(
		  ['precision highp float;'
		  ,'varying vec3 vNormal;'
		  ,'void main() { vec3 n = normalize(vNormal); gl_FragColor = vec4(n*n,1.); }'
		  ].join('\n')
		);
		//*/
		
		var obj2 = new CT.Node();
		obj.addChild(obj2);

		var sphere = new CT.Sphere(128, 128);
		obj2.addChild(sphere);
		obj2.getChild(0).setTexture('images/sun.png');
		
		/*
		obj2.addChild(new CT.Extruded(16,100,
					function(u,v){ v=.30-.06*cos(2*PI*v); u*=4*PI; return [v*cos(u),v*sin(u)] },          // PROFILE
					function(v){v*=4*PI;var r=1-cos(1.5*v)/5;return[sin(1.5*v)/2,r*cos(v),r*sin(v)];})); // PATH
		obj2.getChild(0).setColor([1,0,0]);
		

		obj2.addChild(new CT.Parametric(20,20,function(u,v){return [2*u-1, 2*v-1, sin(1+10*u)*sin(1+10*v)/4];}));
		obj2.getChild(1).setColor([0,1,1]);

		obj2.addChild(new CT.Revolved(16, 8, function(t) { return [sin(PI * 5 * t), 2*t-1]; } ));
		obj2.getChild(2).setColor([0,1,0]);
		//*/
		
		var obj3 = new CT.Node();
		obj.addChild(obj3);

		/*
		obj3.addChild(new CT.Sphere(16, 8));
		obj3.getChild(0).setColor([1,1,1]).setTexture('images/brick.png');

		obj3.addChild(new CT.Square());
		obj3.getChild(1).setColor([1,1,0]).setNormalMap('images/normal_map_1.png');

		obj3.addChild(new CT.Torus(32, 16, .6));
		obj3.getChild(2).setPhong([.1,.04,.01, 1,.4,.1, .2,.2,.2,5])
						   .setTexture('images/This_is_not_a_bagel.jpg')
						   .setNormalMap('images/normal_map_2.jpg');
		//*/
						
		var tube = new CT.Revolved(20, 16, function(t) { return[sin(t * PI / 2) - 10, cos(t * 2 + 1) - 20];});	   
		var obj4 = new CT.Node();
		obj.addChild(obj4);
		obj4.addChild(tube);
		
		document.onkeydown = handleKeyDown;
		document.onkeyup = handleKeyUp;
		canvas1.onmousedown = handleMouseDown;
        document.onmouseup = handleMouseUp;
        document.onmousemove   = handleMouseMove;
		
		var elem = document.getElementById("canvas1");
		elem.requestPointerLock = elem.requestPointerLock ||
									 elem.mozRequestPointerLock ||
                                     elem.webkitRequestPointerLock;

		elem.requestPointerLock();
		
		document.exitPointerLock = document.exitPointerLock ||
			   document.mozExitPointerLock ||
			   document.webkitExitPointerLock;
		document.exitPointerLock();
		
		// Hook pointer lock state change events
		document.addEventListener('pointerlockchange', changeCallback, false);
		document.addEventListener('mozpointerlockchange', changeCallback, false);
		document.addEventListener('webkitpointerlockchange', changeCallback, false);
	}
	
	function handleKeyDown(e) {
		pressedKeys[e.which] = true;
	}
	
	function handleKeyUp(e) {
		pressedKeys[e.which] = false;
	}
	
	function handleKeys() {
		var k = pressedKeys;
		if (k[81]) {
			growBigger = true; //console.log("Q pressed");
		}
		if (k[87]) {
			translZ -= 0.2;//console.log("W pressed");
		}
		if (k[65]) {
			translX -= 0.2;//console.log("A pressed");
		}
		if (k[83]) {
			translZ += 0.2;//console.log("S pressed");
		}
		if (k[68]) {
			translX += 0.2;//console.log("D pressed");
		}
		if (k[69]) {
			shrinkSmaller = true; // console.log("E pressed");
		}
	}

	function handleMouseDown(e) {
		mouseDown = true;
	}

	function handleMouseUp(e) {
		mouseDown = false;
	}

	function handleMouseMove(e) {
		deltaMouseX = e.movementX;
		deltaMouseY = e.movementY;
	}

	//CONVERTS DEGREES TO RADIANS	
	function degreesToRadians(degrees) {
		return degrees * Math.PI / 180;
	}

	//RETURNS DEGREES TO ROTATE CORRESPONDING TO HORIZONTAL MOUSE MOVEMENT
	function getDeltaMouseX() {
		return degreesToRadians(-deltaMouseX / mouseScale);
	}

	//RETURNS DEGREES TO ROTATE CORRESPONDING TO VERTICAL MOUSE MOVEMENT
	function getDeltaMouseY() {
		return degreesToRadians(-deltaMouseY / mouseScale);
	}

	//RETURNS SCALE FOR SCALING OBJECTS
	function getScale() {
		if (growBigger) {
			return scaleFactor;
		}
		if (shrinkSmaller) {
			return 1 / scaleFactor;
		}
		return 1;
	}

	//HANDLES ALL I/O MOVEMENT VIA MOUSE AND KEYBOARD
	function handleMovement() {
		camera = scene._viewMatrix;
		//SET HORIZONTAL MOUSE ROTATION
		worldTransform = CT.matrixRotatedY(getDeltaMouseX());
		//SET VERTICAL MOUSE ROTATION
		worldTransform = CT.matrixMultiply(worldTransform, 
										   CT.matrixRotatedX(getDeltaMouseY()),
										   []);
		//SET FORWARD/BACKWARD AND LEFT/RIGHT MOVEMENT
		worldTransform = CT.matrixMultiply(worldTransform,
										   CT.matrixTranslated(translX, translY, translZ),
										   []);
		//APPLY WORLD TRANSFORM
		camera = CT.matrixMultiply(camera, worldTransform, []);
		scene.setViewMatrix(camera);
	}

	function objectDraw() {
		for (var i = 0 ; i < obj.numChildren() ; i++) {
			var currObj = obj.getChild(i);
			//currObj.translate(Math.sin(Math.PI * time - (Math.PI * time / 2)), 0, 0);
			for (var j =0; j < currObj.numChildren(); ++j) {
				currObj.getChild(j).identity().translate(4*(j%4)-6, j<4?2:-2, 0).rotateY(time).rotateX(time/2);
			}
		}
		obj.draw();
		//SCALE ALL OBJECTS BIGGER OR SMALLER
		if (growBigger || shrinkSmaller) {
			obj.scale(getScale(), getScale(), getScale());
		}
	}

	function resetProperties() {
		translX = 0;
		translY = 0;
		translZ = 0;
		deltaMouseX = 0;
		deltaMouseY = 0;
		growBigger = false;
		shrinkSmaller = false;
		worldTransform = CT.matrixIdentity();
	}

	function update() {
	    // when element is clicked, we're going to request a
        // pointerlock
		(function($){
        $("#pointerLock").click(function () {
            var canvas = $("#pointerLock").get()[0];
            canvas.requestPointerLock = canvas.requestPointerLock ||
                    canvas.mozRequestPointerLock ||
                    canvas.webkitRequestPointerLock;
 
            // Ask the browser to lock the pointer)
            canvas.requestPointerLock();
        });
		 })(jQuery); 
	
		objectDraw();
		handleKeys();
		handleMovement();
		resetProperties();
	}

	setTimeout(function() {
			init();
			setInterval(function() {
				window.time = (new Date()).getTime() / 1000;
				update();
			}, 16);
		}, 100
	);
</script>
<center>
<canvas id=canvas1 height=720 width=1080 style="background:black;"></canvas>
</center>
</body>
